{"version":3,"file":"index.mjs","sources":["../src/utils/error.ts","../src/utils/file-name.ts","../src/utils/has-property.ts","../src/utils/object.ts","../src/utils/to-array.ts","../src/locator/utils.ts","../src/locator/async.ts","../src/locator/sync.ts","../src/loader/utils.ts","../src/loader/built-in/module/utils.ts","../src/loader/built-in/module/module.ts","../src/loader/built-in/json/module.ts","../src/loader/constants.ts","../src/loader/module.ts","../src/loader/singleton.ts","../src/loader/helpers.ts"],"sourcesContent":["/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\n/* istanbul ignore next */\nexport function handleFileLoadError(e: unknown) : void {\n    if (e instanceof Error) {\n        throw e;\n    }\n\n    if (typeof e === 'string') {\n        throw new Error(e);\n    }\n\n    throw new Error('Cannot determine file loading error.');\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function removeFileNameExtension(\n    input: string,\n    extensions?: string[],\n) {\n    if (input.includes('.')) {\n        const position = input.lastIndexOf('.');\n        const extension = input.substring(\n            position,\n            input.length,\n        );\n\n        if (\n            typeof extensions === 'undefined' ||\n            extensions.indexOf(extension) !== -1\n        ) {\n            input = input.substring(0, position);\n        }\n    }\n\n    return input;\n}\n","export function hasOwnProperty<X extends Record<string, any>, Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, unknown> {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nexport function hasStringProperty<X extends Record<string, any>, Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, string> {\n    return hasOwnProperty(obj, prop) && typeof obj[prop] === 'string';\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function isObject(item: unknown) : item is Record<string, any> {\n    return (\n        !!item &&\n        typeof item === 'object' &&\n        !Array.isArray(item)\n    );\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function toArray(input: string | string[]) : string[] {\n    return Array.isArray(input) ? input : [input];\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport path from 'node:path';\nimport type { LocatorInfo, LocatorOptions } from './type';\nimport { toArray } from '../utils';\n\nexport function buildLocatorOptions(options?: Partial<LocatorOptions>) : LocatorOptions {\n    options = options || {};\n\n    options.path = options.path || [];\n    options.path = toArray(options.path);\n    if (options.path.length === 0) {\n        options.path.push(process.cwd());\n    }\n\n    options.ignore ??= [];\n\n    return options as LocatorOptions;\n}\n\nexport function isFilePath(input: string) {\n    const info = path.parse(input);\n    return info.ext !== '';\n}\n\nexport function pathToLocatorInfo(\n    input: string,\n    skipResolve?: boolean,\n) : LocatorInfo {\n    if (\n        !skipResolve &&\n        !path.isAbsolute(input)\n    ) {\n        input = path.resolve(process.cwd(), input);\n    }\n\n    const info = path.parse(input);\n\n    return {\n        path: info.dir.split('/').join(path.sep),\n        name: info.name,\n        extension: info.ext,\n    };\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport glob from 'glob';\nimport { promisify } from 'node:util';\nimport type { LocatorInfo, LocatorOptions } from './type';\nimport { buildLocatorOptions, pathToLocatorInfo } from './utils';\n\nconst globAsync = promisify(glob);\n\nexport async function locateMany(\n    pattern: string | string[],\n    options?: Partial<LocatorOptions>,\n) : Promise<LocatorInfo[]> {\n    options = buildLocatorOptions(options);\n\n    const patterns = Array.isArray(pattern) ?\n        pattern :\n        [pattern];\n\n    const items : LocatorInfo[] = [];\n\n    for (let i = 0; i < patterns.length; i++) {\n        for (let j = 0; j < (options as LocatorOptions).path.length; j++) {\n            const files = await globAsync(patterns[i] as string, {\n                absolute: true,\n                cwd: (options as LocatorOptions).path[j],\n                nodir: true,\n                ignore: options.ignore,\n            });\n\n            for (let k = 0; k < files.length; k++) {\n                items.push(pathToLocatorInfo(files[k] as string, true));\n            }\n        }\n    }\n\n    return items;\n}\n\nexport async function locate(\n    pattern: string | string[],\n    options?: Partial<LocatorOptions>,\n) : Promise<LocatorInfo | undefined> {\n    options = buildLocatorOptions(options);\n\n    const patterns = Array.isArray(pattern) ?\n        pattern :\n        [pattern];\n\n    for (let i = 0; i < patterns.length; i++) {\n        for (let j = 0; j < (options as LocatorOptions).path.length; j++) {\n            const files = await globAsync(patterns[i] as string, {\n                absolute: true,\n                cwd: (options as LocatorOptions).path[j],\n                nodir: true,\n                ignore: options.ignore,\n            });\n\n            const element = files.shift();\n            if (element) {\n                return pathToLocatorInfo(element, true);\n            }\n        }\n    }\n\n    return undefined;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport glob from 'glob';\nimport type { LocatorInfo, LocatorOptions } from './type';\nimport { buildLocatorOptions, pathToLocatorInfo } from './utils';\n\nexport function locateManySync(\n    pattern: string | string[],\n    options?: Partial<LocatorOptions>,\n) : LocatorInfo[] {\n    options = buildLocatorOptions(options);\n\n    const patterns = Array.isArray(pattern) ?\n        pattern :\n        [pattern];\n\n    const items : LocatorInfo[] = [];\n\n    for (let i = 0; i < patterns.length; i++) {\n        for (let j = 0; j < (options as LocatorOptions).path.length; j++) {\n            const files = glob.sync(patterns[i] as string, {\n                absolute: true,\n                cwd: (options as LocatorOptions).path[j],\n                nodir: true,\n                ignore: options.ignore,\n            });\n\n            for (let k = 0; k < files.length; k++) {\n                items.push(pathToLocatorInfo(files[k] as string, true));\n            }\n        }\n    }\n\n    return items;\n}\n\nexport function locateSync(\n    pattern: string | string[],\n    options?: Partial<LocatorOptions>,\n) : LocatorInfo | undefined {\n    options = buildLocatorOptions(options);\n\n    const patterns = Array.isArray(pattern) ?\n        pattern :\n        [pattern];\n\n    for (let i = 0; i < patterns.length; i++) {\n        for (let j = 0; j < (options as LocatorOptions).path.length; j++) {\n            const files = glob.sync(patterns[i] as string, {\n                absolute: true,\n                cwd: (options as LocatorOptions).path[j],\n                nodir: true,\n                ignore: options.ignore,\n            });\n\n            const element = files.shift();\n            if (element) {\n                return pathToLocatorInfo(element, true);\n            }\n        }\n    }\n\n    return undefined;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { BaseError } from 'ebec';\nimport path from 'node:path';\nimport type { LocatorInfo } from '../locator';\nimport { pathToLocatorInfo } from '../locator';\nimport { hasOwnProperty } from '../utils';\nimport type { LoaderFilterFn, ScriptFileExportItem } from './built-in';\n\nexport function buildLoaderFilePath(input: LocatorInfo | string, withExtension?: boolean) {\n    let info: LocatorInfo;\n\n    if (typeof input === 'string') {\n        info = pathToLocatorInfo(input);\n    } else {\n        info = input;\n    }\n\n    if (\n        withExtension &&\n        info.extension\n    ) {\n        return path.join(info.path, info.name) + info.extension;\n    }\n\n    return path.join(info.path, info.name);\n}\n\nexport function getExportItem(\n    data: Record<string, any>,\n    filterFn?: LoaderFilterFn,\n): ScriptFileExportItem {\n    if (filterFn) {\n        const keys = Object.keys(data);\n        for (let i = 0; i < keys.length; i++) {\n            if (filterFn(keys[i] as string, data[keys[i] as string])) {\n                return {\n                    key: keys[i] as string,\n                    value: data[keys[i] as string],\n                };\n            }\n        }\n\n        throw new BaseError('Cannot find specific module export.');\n    }\n\n    return {\n        key: 'default',\n        value: hasOwnProperty(data, 'default') ? data.default : data,\n    };\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function isJestRuntimeEnvironment() : boolean {\n    return process.env &&\n        process.env.JEST_WORKER_ID !== undefined;\n}\n\nexport function isTsNodeRuntimeEnvironment() : boolean {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return !!process[Symbol.for('ts-node.register.instance')];\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { BaseError } from 'ebec';\nimport type { JITI } from 'jiti';\nimport createJITI from 'jiti';\nimport { pathToFileURL } from 'node:url';\nimport type { LocatorInfo } from '../../../locator';\nimport { pathToLocatorInfo } from '../../../locator';\nimport { handleFileLoadError, hasStringProperty, isObject } from '../../../utils';\nimport type { Loader } from '../../type';\nimport { buildLoaderFilePath } from '../../utils';\nimport type { ScriptFileLoadOptions } from './type';\nimport { isJestRuntimeEnvironment, isTsNodeRuntimeEnvironment } from './utils';\n\nexport class ModuleLoader implements Loader {\n    protected jiti : JITI;\n\n    constructor() {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        this.jiti = createJITI(undefined, {\n            extensions: ['.js', '.mjs', '.mts', '.cjs', '.cts', '.ts'],\n        });\n    }\n\n    async execute(input: string) {\n        let output : any;\n\n        try {\n            output = await this.load(input);\n        } catch (e) {\n            // jiti + ts-node\n            // issue: https://github.com/nuxt/bridge/issues/228\n            if (isTsNodeRuntimeEnvironment()) {\n                output = this.loadSync(input);\n            } else {\n                output = this.jiti(input);\n            }\n        }\n\n        return output;\n    }\n\n    executeSync(input: string) {\n        let output : any;\n\n        try {\n            output = this.loadSync(input);\n        } catch (e) {\n            output = this.jiti(input);\n        }\n\n        return output;\n    }\n\n    // ---------------------------------------------------------------------------\n\n    async load(\n        data: LocatorInfo | string,\n        options?: ScriptFileLoadOptions,\n    ) : Promise<unknown> {\n        let locatorInfo : LocatorInfo;\n\n        if (typeof data === 'string') {\n            locatorInfo = pathToLocatorInfo(data);\n        } else {\n            locatorInfo = data;\n        }\n\n        options = options || {};\n\n        let filePath = buildLoaderFilePath(locatorInfo, options.withExtension);\n        if (options.withFilePrefix) {\n            filePath = pathToFileURL(filePath).href;\n        }\n\n        try {\n            // segmentation fault\n            // issue: https://github.com/nodejs/node/issues/35889\n            if (isJestRuntimeEnvironment()) {\n                // eslint-disable-next-line global-require,import/no-dynamic-require\n                return require(filePath);\n            }\n\n            return await import(filePath);\n        } catch (e) {\n            /* istanbul ignore next */\n            if (\n                isObject(e) &&\n                hasStringProperty(e, 'code')\n            ) {\n                if (\n                    !options.withExtension &&\n                    (\n                        e.code === 'ERR_MODULE_NOT_FOUND' ||\n                        e.code === 'MODULE_NOT_FOUND'\n                    )\n                ) {\n                    return this.load(locatorInfo, {\n                        ...options,\n                        withExtension: true,\n                    });\n                }\n\n                if (\n                    !options.withFilePrefix &&\n                    (\n                        e.code === 'ERR_UNSUPPORTED_ESM_URL_SCHEME' ||\n                        e.code === 'UNSUPPORTED_ESM_URL_SCHEME'\n                    )\n                ) {\n                    return this.load(locatorInfo, {\n                        ...options,\n                        withFilePrefix: true,\n                    });\n                }\n\n                throw new BaseError({\n                    code: e.code,\n                    message: hasStringProperty(e, 'message') ? e.message : undefined,\n                    stack: hasStringProperty(e, 'stack') ? e.stack : undefined,\n                });\n            }\n\n            /* istanbul ignore next */\n            return handleFileLoadError(e);\n        }\n    }\n\n    loadSync(\n        data: LocatorInfo | string,\n        options?: ScriptFileLoadOptions,\n    ) : unknown {\n        let locatorInfo : LocatorInfo;\n\n        if (typeof data === 'string') {\n            locatorInfo = pathToLocatorInfo(data);\n        } else {\n            locatorInfo = data;\n        }\n\n        options = options || {};\n\n        const filePath = buildLoaderFilePath(locatorInfo, options.withExtension);\n\n        try {\n            // eslint-disable-next-line global-require,import/no-dynamic-require\n            return require(filePath);\n        } catch (e) {\n            /* istanbul ignore next */\n            if (\n                isObject(e) &&\n                hasStringProperty(e, 'code')\n            ) {\n                if (\n                    !options.withExtension &&\n                    (\n                        e.code === 'ERR_MODULE_NOT_FOUND' ||\n                        e.code === 'MODULE_NOT_FOUND'\n                    )\n                ) {\n                    return this.loadSync(locatorInfo, {\n                        ...options,\n                        withExtension: true,\n                    });\n                }\n\n                throw new BaseError({\n                    code: e.code,\n                    message: hasStringProperty(e, 'message') ? e.message : undefined,\n                    stack: hasStringProperty(e, 'stack') ? e.stack : undefined,\n                });\n            }\n\n            return handleFileLoadError(e);\n        }\n    }\n}\n","/*\n * Copyright (c) 2022-2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport fs from 'node:fs';\nimport { handleFileLoadError } from '../../../utils';\nimport type { Loader } from '../../type';\nimport { buildLoaderFilePath } from '../../utils';\n\nexport class JSONLoader implements Loader {\n    async execute(input: string) {\n        const filePath = buildLoaderFilePath(input, true);\n\n        try {\n            const file = await fs.promises.readFile(filePath);\n            return JSON.parse(file.toString('utf-8'));\n        } catch (e) {\n            return handleFileLoadError(e);\n        }\n    }\n\n    executeSync(input: string) {\n        const filePath = buildLoaderFilePath(input, true);\n\n        try {\n            const file = fs.readFileSync(filePath);\n            return JSON.parse(file.toString('utf-8'));\n        } catch (e) {\n            return handleFileLoadError(e);\n        }\n    }\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport enum LoaderId {\n    MODULE = 'module',\n    JSON = 'json',\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport path from 'node:path';\nimport { isFilePath, pathToLocatorInfo } from '../locator';\nimport { JSONLoader, ModuleLoader } from './built-in';\nimport { LoaderId } from './constants';\nimport type { Loader, Rule } from './type';\nimport { buildLoaderFilePath } from './utils';\n\nexport class LoaderManager implements Loader {\n    protected loaders : Record<string, Loader>;\n\n    protected rules : Rule[];\n\n    constructor() {\n        this.loaders = {};\n        this.rules = [\n            {\n                test: ['.js', '.mjs', '.mts', '.cjs', '.cts', '.ts'],\n                loader: LoaderId.MODULE,\n            },\n            {\n                test: ['.json'], loader: LoaderId.JSON,\n            },\n        ];\n    }\n\n    register(rule: Rule) : void;\n\n    register(test: string[] | RegExp, loader: Loader) : void;\n\n    register(test: any, loader?: Loader) : void {\n        if (typeof loader !== 'undefined') {\n            this.rules.push({ test, loader });\n            return;\n        }\n\n        this.rules.push(test);\n    }\n\n    async execute(input: string) : Promise<any> {\n        const id = this.findLoader(input);\n        if (!id) {\n            const info = pathToLocatorInfo(input);\n            throw new Error(`No loader registered for extension: \"${info.extension}\"`);\n        }\n\n        const loader = this.resolve(id);\n        return loader.execute(input);\n    }\n\n    executeSync(input: string) : any {\n        const id = this.findLoader(input);\n        if (!id) {\n            const info = pathToLocatorInfo(input);\n            throw new Error(`No loader registered for extension: ${info.extension || 'unknown'}`);\n        }\n\n        const loader = this.resolve(id);\n        return loader.executeSync(input);\n    }\n\n    findLoader(input: string) : Loader | string | undefined {\n        if (!isFilePath(input)) {\n            return LoaderId.MODULE;\n        }\n\n        const info = pathToLocatorInfo(input);\n        for (let i = 0; i < this.rules.length; i++) {\n            const { test } = this.rules[i] as Rule;\n            if (Array.isArray(test)) {\n                if (test.indexOf(info.extension) !== -1) {\n                    return this.rules[i].loader;\n                }\n            } else if (test.test(buildLoaderFilePath(info))) {\n                return this.rules[i].loader;\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Resolve loader by id.\n     *\n     * @param id\n     */\n    resolve(id: string | Loader) : Loader {\n        if (typeof id !== 'string') {\n            return id;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(this.loaders, id)) {\n            return this.loaders[id] as Loader;\n        }\n\n        let loader : Loader | undefined;\n\n        // built-in\n        switch (id) {\n            case LoaderId.MODULE: {\n                loader = new ModuleLoader();\n                break;\n            }\n            case LoaderId.JSON: {\n                loader = new JSONLoader();\n                break;\n            }\n            /* istanbul ignore next */\n            default: {\n                const pluginPath = this.normalizePath(id);\n                const moduleLoader = this.resolve(LoaderId.MODULE);\n                loader = moduleLoader.executeSync(pluginPath);\n\n                break;\n            }\n        }\n\n        if (typeof loader !== 'undefined') {\n            this.loaders[id] = loader;\n\n            return loader;\n        }\n\n        throw new Error(`The loader ${id} could not be resolved.`);\n    }\n\n    /* istanbul ignore next */\n    normalizePath(input: string) {\n        if (path.isAbsolute(input) || input.startsWith('./')) {\n            return input;\n        }\n\n        if (input.startsWith('module:')) {\n            return input.substring(0, 'module:'.length);\n        }\n\n        if (!input.startsWith('@')) {\n            return `@locter/${input}`;\n        }\n\n        return input;\n    }\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { LoaderManager } from './module';\n\nlet instance : LoaderManager;\nexport function useLoader() {\n    if (typeof instance !== 'undefined') {\n        return instance;\n    }\n\n    instance = new LoaderManager();\n\n    return instance;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport type { LocatorInfo } from '../locator';\nimport { useLoader } from './singleton';\nimport type { Loader, Rule } from './type';\nimport { buildLoaderFilePath } from './utils';\n\nexport function registerLoader(rule: Rule) : void;\nexport function registerLoader(test: string[] | RegExp, loader: Loader) : void;\nexport function registerLoader(test: any, loader?: Loader) : void {\n    const manager = useLoader();\n    if (typeof loader !== 'undefined') {\n        manager.register(test, loader);\n\n        return;\n    }\n\n    manager.register(test);\n}\n\nexport async function load(input: LocatorInfo | string) : Promise<any> {\n    const manager = useLoader();\n    if (typeof input === 'string') {\n        return manager.execute(input);\n    }\n\n    return manager.execute(buildLoaderFilePath(input, true));\n}\n\nexport function loadSync(input: LocatorInfo | string) : any {\n    const manager = useLoader();\n    if (typeof input === 'string') {\n        return manager.executeSync(input);\n    }\n\n    return manager.executeSync(buildLoaderFilePath(input, true));\n}\n"],"names":["input","options","name","extension","pattern","absolute","cwd","nodir","ignore","items","info","value","output","executeSync","locatorInfo","withExtension","withFilePrefix","code","message","stack","LoaderId","test","loader","findLoader","instance","manager"],"mappings":";;;;;;;;;;;;;;;AAAA;;;;;AAKC;AAIG;AACI;;;;;;AAQR;;AClBA;;;;;AAKC;;;AAQO;;;;;;AAcR;;AC3BO;AACH;AACJ;AAEO;AACH;AACJ;;ACNA;;;;;AAKC;;AAQD;;ACbA;;;;;AAKC;AAGG;AAAuCA;AAAM;AACjD;;ACTA;;;;;;AAWO;AACHC;AAEAA;AACAA;AACA;AACIA;;AAGJA;;AAGJ;AAEO;;;AAGP;AAEO;AAIH;AAIID;;;;;AAOAE;AACAC;AACJ;AACJ;;ACpCA;AAEO;AAIHF;AAEA;AAEKG;AAAQ;AAEb;AAEA;;AAEQ;AACIC;AACAC;AACAC;AACAC;AACJ;AAEA;AACIC;AACJ;AACJ;AACJ;;AAGJ;AAEO;AAIHR;AAEA;AAEKG;AAAQ;AAEb;;AAEQ;AACIC;AACAC;AACAC;AACAC;AACJ;;AAGA;;;AAGJ;AACJ;;AAGJ;;AC5DO;AAIHP;AAEA;AAEKG;AAAQ;AAEb;AAEA;;AAEQ;AACIC;AACAC;AACAC;AACAC;AACJ;AAEA;AACIC;AACJ;AACJ;AACJ;;AAGJ;AAEO;AAIHR;AAEA;AAEKG;AAAQ;AAEb;;AAEQ;AACIC;AACAC;AACAC;AACAC;AACJ;;AAGA;;;AAGJ;AACJ;;AAGJ;;ACtDO;;;AAICE;;;;;;;AAYJ;AACJ;AAEO;AAIH;;AAEI;;;;AAIYC;AACJ;;AAER;;;;;AAOAA;AACJ;AACJ;;ACvDA;;;;;;AAQI;AAEJ;AAEO;;;AAGH;AACJ;;ACGO;;;;AAeKC;AACJ;;;AAGI;;;;;AAKJ;;AAGJ;AAEAC;;;;AAKI;;AAEA;;AAGJ;;AAIA;;;AAOQC;;;;AAKJb;AAEA;;;;;;;AAQI;;AAEI;;;AAIR;AACI;AAKI;AAOI;AACI;AACAc;AACJ;;AAGJ;AAOI;AACI;AACAC;AACJ;;AAGJ;AACIC;AACAC;AACAC;;;;AAMZ;AACJ;;;;AASQL;;;;AAKJb;AAEA;;;AAII;AACJ;AACI;AAKI;AAOI;AACI;AACAc;AACJ;;AAGJ;AACIE;AACAC;AACAC;;;AAIR;AACJ;AACJ;;;;AA5JI;;AACiB;AAAO;AAAQ;AAAQ;AAAQ;AAAQ;AAAM;AAC9D;AACJ;AA0JJ;;AC1KO;;;;AAKK;AACA;AACJ;AACI;AACJ;AACJ;AAEAN;;;;AAKQ;AACJ;AACI;AACJ;AACJ;AACJ;;AClCA;;;;;;;AAOYO;AAAAA;;;ACOL;;;AAwBK;AAAkBC;AAAMC;AAAO;AAC/B;;AAGJ;AACJ;;AAGI;AACA;AACI;;;AAIJ;;AAEJ;AAEAT;AACI;AACA;AACI;;;AAIJ;;AAEJ;AAEAU;;AAEQ;;AAGJ;;;;AAIQ;AACI;;AAER;AACI;;AAER;;AAGJ;AAEA;;;;;;;;;AAWQ;;;;;AAOA;AAAsB;AAClBD;;AAEJ;AACA;AAAoB;AAChBA;;AAEJ;AACA;AACS;AACL;AACA;;;AAIJ;AACJ;;AAGI;;;;AAMR;;AAII;;;;AAKI;;AAGJ;AACI;;;AAIR;;;;AA7HQ;;AACW;AAAO;AAAQ;AAAQ;AAAQ;AAAQ;AAAM;AACpDA;AACJ;AACA;;AACW;AAAQ;AAAEA;AACrB;AACH;AACL;AAsHJ;;AC3IA;AACO;;;;AAKHE;;AAGJ;;ACJO;AACH;;;AAII;;AAGJC;AACJ;AAEO;AACH;;;;AAKA;AACJ;AAEO;AACH;;;;AAKA;AACJ;;"}